module AbstLang where

import           BaseLang

data ATwo = Zero | One deriving(Eq, Show)

alpha :: D -> ATwo
alpha Nothing = Zero
alpha _       = One

(∧) :: ATwo -> ATwo -> ATwo
Zero ∧ _ = Zero
_ ∧ Zero = Zero
_ ∧ _    = One

(∨) :: ATwo -> ATwo -> ATwo
One ∨ _ = One
_ ∨ One = One
_ ∨ _   = Zero

type AEnv = [(String, ATwo)]
type APhi = [(String, [ATwo] -> ATwo)]

evalAExp :: Exp -> APhi -> AEnv -> ATwo
evalAExp (Const x) _ _ = One
evalAExp (Var key) _ env =
    case lookup key env of
        Nothing     -> Zero
        Just result -> result
evalAExp (Add x y) phi env = (evalAExp x phi env) ∧ (evalAExp y phi env)
evalAExp (Sub x y) phi env = (evalAExp x phi env) ∧ (evalAExp y phi env)
evalAExp (Mul x y) phi env = (evalAExp x phi env) ∧ (evalAExp y phi env)
evalAExp (Eq x y)  phi env = deq (evalAExp x phi env) (evalAExp y phi env)
    where
        deq :: ATwo -> ATwo -> ATwo
        deq a b = if a == b then One else Zero
evalAExp (GEq x y) phi env = dgeq (evalAExp x phi env) (evalAExp y phi env)
    where
        dgeq :: ATwo -> ATwo -> ATwo
        dgeq One _ = One
        dgeq Zero One = One
        dgeq _ _ = Zero
evalAExp (If cond thenBranch elseBranch) phi env = c ∧ (t ∨ e)
    where
        c = evalAExp cond phi env
        t = evalAExp thenBranch phi env
        e = evalAExp elseBranch phi env
    case evalAExp cond phi env of
        Nothing -> Nothing
        Just x  -> evalExp (if x == 0 then elseBranch else thenBranch) phi env
evalAExp (Call fname args) phi env =
    case (lookup fname phi) of
        Nothing -> Nothing
        Just f  -> f (map (\a -> evalExp a phi env) args)
evalAExp (StrictCall fname args) phi env =
    case (lookup fname phi) of
        Nothing -> Nothing
        Just f  -> strict f (map (\a -> evalExp a phi env) args)
    where 
        strict :: ([D] -> D) -> [D] -> D
        strict f args = 
            if noneIsNothing args
                then f args
                else Nothing
